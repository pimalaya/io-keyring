//! # Sans I/O
//!
//! This module contains the state machine [`Flow`] and [`Io`]
//! definitions, as well as commonly-used flows definition like
//! [`ReadEntryFlow`], [`WriteEntryFlow`] and [`DeleteEntryFlow`].

use secrecy::SecretSlice;

/// The type of I/O generated by keyring [`Flow`] state machines.
///
/// This enum is the representation of I/Os that need to be performed
/// outside of [`Flow`]s.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Io {
    Read,
    Write,
    Delete,
}

/// Trait used for building keyring-related sans I/O state machine
/// flows.
///
/// A flow is defined as an iterable state machine, where every
/// `.next()` call produces a potential [`Io`] that needs to be
/// performed outside of the flow, and makes the state go forward. No
/// [`Io`] produced means that the flow is terminated and does not
/// require any longer [`Io`] to be performed.
pub trait Flow: Iterator {}

/// Trait dedicated to flows that operate on specific keyring entries.
///
/// This trait make sure that the given flow knows how to retrieve the
/// key of the targeted keyring entry.
pub trait GetKey: Flow {
    fn get_key(&self) -> &str;
}

/// Trait dedicated to flows that needs to take secrets.
///
/// This trait make sure that the given flow knows how to take a
/// secret from its inner state.
pub trait TakeSecret: Flow {
    fn take_secret(&mut self) -> Option<SecretSlice<u8>>;
}

/// Trait dedicated to flows that needs to put secrets.
///
/// This trait make sure that the given flow knows how to put a secret
/// into its inner state.
pub trait PutSecret: Flow {
    fn put_secret(&mut self, secret: SecretSlice<u8>);
}

/// [`Flow`] for reading a secret from a keyring entry.
#[derive(Clone, Debug)]
pub struct ReadEntryFlow {
    key: String,
    secret: Option<SecretSlice<u8>>,
}

impl ReadEntryFlow {
    /// Creates a new [`ReadEntryFlow`] from the given keyring entry
    /// key.
    pub fn new(key: impl ToString) -> Self {
        Self {
            key: key.to_string(),
            secret: None,
        }
    }
}

impl Iterator for ReadEntryFlow {
    type Item = Io;

    fn next(&mut self) -> Option<Self::Item> {
        if self.secret.is_none() {
            Some(Io::Read)
        } else {
            None
        }
    }
}

impl Flow for ReadEntryFlow {}

impl GetKey for ReadEntryFlow {
    fn get_key(&self) -> &str {
        self.key.as_str()
    }
}

impl TakeSecret for ReadEntryFlow {
    fn take_secret(&mut self) -> Option<SecretSlice<u8>> {
        self.secret.take()
    }
}

impl PutSecret for ReadEntryFlow {
    fn put_secret(&mut self, secret: SecretSlice<u8>) {
        self.secret.replace(secret);
    }
}

/// [`Flow`] for writing a secret into a keyring entry.
#[derive(Clone, Debug)]
pub struct WriteEntryFlow {
    key: String,
    secret: Option<SecretSlice<u8>>,
}

impl WriteEntryFlow {
    /// Creates a new [`WriteEntryFlow`] from the given keyring entry
    /// key and the given secret.
    pub fn new(key: impl ToString, secret: impl Into<SecretSlice<u8>>) -> Self {
        Self {
            key: key.to_string(),
            secret: Some(secret.into()),
        }
    }
}

impl Iterator for WriteEntryFlow {
    type Item = Io;

    fn next(&mut self) -> Option<Self::Item> {
        if self.secret.is_some() {
            Some(Io::Write)
        } else {
            None
        }
    }
}

impl Flow for WriteEntryFlow {}

impl GetKey for WriteEntryFlow {
    fn get_key(&self) -> &str {
        self.key.as_str()
    }
}

impl TakeSecret for WriteEntryFlow {
    fn take_secret(&mut self) -> Option<SecretSlice<u8>> {
        self.secret.take()
    }
}

impl PutSecret for WriteEntryFlow {
    fn put_secret(&mut self, secret: SecretSlice<u8>) {
        self.secret.replace(secret);
    }
}

/// [`Flow`] for deleting a secret from a keyring entry.
#[derive(Clone, Debug)]
pub struct DeleteEntryFlow {
    key: String,
    deleted: bool,
}

impl DeleteEntryFlow {
    pub fn new(key: impl ToString) -> Self {
        Self {
            key: key.to_string(),
            deleted: false,
        }
    }
}

impl Iterator for DeleteEntryFlow {
    type Item = Io;

    fn next(&mut self) -> Option<Self::Item> {
        if self.deleted {
            None
        } else {
            self.deleted = true;
            Some(Io::Delete)
        }
    }
}

impl Flow for DeleteEntryFlow {}

impl GetKey for DeleteEntryFlow {
    fn get_key(&self) -> &str {
        self.key.as_str()
    }
}
